/*
 * Projeto COSMOS Display.c
 *	In this project the EEPROM memory data is generated by SERIAL communication and generate display content, with horizontal scroll animation.
 *  
 * Created: 11/02/2018 23:48:27
 * Author : DAVID
 */ 

#include "Definitions.h"

//CARACTERES. 
PROGMEM const unsigned char IMAGES[39][9]  = {		//IMAGES[DIGITO][LINHA]   
	    {0x09,0b00111100,0b01111110,0b11100011,0b11010011,0b11001011,0b11000111,0b01111110,0b00111100}, //0
	    {0x07,0b11000100,0b11000110,0b11111111,0b11111111,0b11000000,0b11000000,0b00000000,0b00000000}, //1
	    {0x08,0b11000100,0b11100110,0b11110011,0b11111011,0b11011111,0b11001111,0b11000110,0b00000000}, //2
	    {0x07,0b01000010,0b11000011,0b11011011,0b11011011,0b11111111,0b01111110,0b00000000,0b00000000}, //3
	    {0x07,0b00001111,0b00011111,0b00011000,0b00011000,0b11111111,0b11111111,0b00000000,0b00000000}, //4
	    {0x07,0b11011111,0b11011111,0b11011011,0b11011011,0b11111011,0b01110011,0b00000000,0b00000000}, //5
	    {0x07,0b01111110,0b11111111,0b11011011,0b11011011,0b11111011,0b01110011,0b00000000,0b00000000}, //6
	    {0x08,0b10000111,0b11000111,0b11100011,0b01110011,0b00111111,0b00011111,0b00001110,0b00000000}, //7
	    {0x08,0b00110100,0b01111110,0b11011011,0b11001011,0b11011011,0b01111110,0b00110100,0b00000000}, //8
	    {0x07,0b01001110,0b11011111,0b11011011,0b11011011,0b11111111,0b01111110,0b00000000,0b00000000}, //9
	    {0x03,0b00110110,0b00110110,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000}, //:
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //A
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //B
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //C
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //D
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //E
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //F
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //G
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //H
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //I
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //J
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //K
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //L
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //M
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //N
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //O
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //P
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //Q
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //R
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //S
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //T
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //U
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //V
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //W
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //X
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //Y
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000}, //Z
	    {0x07,0b00111100,0b01100110,0b11001011,0b11010011,0b01100110,0b00111100,0b00000000,0b00000000} //espaço
};


char STARTUP[7] = {0x48, 0x45, 0x4C, 0x4C, 0x4F, KEYBOARD_ENTER} ;	//MENSAGEM INICIAL: HELLO
char BUFFER[BUFFER_SIZE];

//-----------------------------------------------------

//VARIAVEIS GLOBAIS

volatile char var_flags					= 0x00;
volatile unsigned int buffer_data_size	= 0x00;		//UTILIZADA POR ANIMACAO HORIZONTAL SCROLL
volatile int  eeprom_address			= 0x00;		//UTILIZADA PELA INTERRUPCAO SERIAL
volatile unsigned char h_scroll			= 0x00;			//VARIAVEL UTILIZADA POR TIMER1
volatile unsigned char line				= 0x00;		//VARIAVEL UTILIZADA POR TIMER0
volatile unsigned char tmr2_aux         = 0x00;

//-----------------------------------------------------

//PROTOTIPOS


void re_buffer(char *data);										//ATUALIZA CONTEUDO DE BUFFER
																
void display(char *data, unsigned char anim2, unsigned char linha);					
																//ATUALIZA DISPLAY COM CONTEUDO INDICADO
																//DEVE SER CHAMADA PERIODICAMENTE COM INCREMENTO DO PARAMETRO 'LINHA' PARA MULTIPLEXACAO																
																//PARAMETRO 01: DADOS A SEREM ENVIADOS A DISPLAY
																//PARAMETRO 02: DESLOCAMENTO HORIZONTAL
																//PARAMETRO 03: LINHA A SER TRATADA
																
void setup();													//CONFIGURA FLAGS SALVAS EM EEPROM
void sleep_mode(char mode);

	
//-----------------------------------------------------


ISR(TIMER0_OVF_vect)	//RESPONSAVEL POR CHAMAR A FUNCAO 'DISPLAY'
{	
	display(BUFFER, h_scroll, line);	
	line ++;
	if(line >= DISP_ROWS_QTY)
		line = 0x00;	
}

ISR(TIMER1_OVF_vect)	//RESPONSAVEL POR: HORIZONTAL SCROLL
{
	//CASO VALOR DE h_scroll FOR 0, O DISPLAY ESTAR EXIBINDO EM SUA ULTIMA COLUNA O CONDEUDO, OU SEJA O DISPLAY NUNCA FICAR VAZIO.
	//PARA CENTRALIZAR O TEXTO O VALOR DE h_scroll DEVE SER DISP_COLUMNS_QTY-1
	
	TCNT1L = 0XEE;										//INICIALIZA TIMER1 EM 34286
	TCNT1H = 0X85;										//...	
	
	if (buffer_data_size>DISP_COLUMNS_QTY)				//O CONTEUDO DO TEXTO E MAIOR QUE O DISPLAY?
	{													//SIM, EXECUTA HORIZONTAL SCROLL
		h_scroll ++;
		if (h_scroll >= (buffer_data_size+DISP_COLUMNS_QTY)-1)	//TEXTO ROLOU COMPLETAMENTE?
		{
			h_scroll = 0x00;							//RESETA
		}
	}
	
	else
	{													//NAO?			
		h_scroll  = DISP_COLUMNS_QTY-1;					//CENTRALIZA TEXTO
		TIMSK1 = 0X00;									//TIMER1 NAO SE FAZ NECESSARIO ATE PROXIMO REBUFFER
	}
	
}//INTERRUPCAO TIMER1

ISR(TIMER2_OVF_vect)	//RESPONSAVEL POR STARTUP
{
	tmr2_aux++;						//INCREMENTA VARIAVEL AUXILIAR	
	if (tmr2_aux == 0x64)			//AUXILIAR IGUAL A 100?
	{	
		re_buffer(CALL_EEPROM);		//GERA CONTEUDO DE EEPROM EM BUFFER
		TIMSK2 = 0X00;				//DESLIGA TIMER2
	}
	
}	

ISR(USART_RX_vect)
{		
	unsigned char dado_recebido;					
	unsigned char settings;	
				
	if (!SERIAL_RX_CHECK_ERROR())												//CASO NAO EXISTA ERRO REGISTRADO TRATA DADO
	{
		dado_recebido = SERIAL_RX();											//LE DADO DA SERIAL E SALVA NA VARIAVEL
	
		if (dado_recebido == KEYBOARD_UNDERLINE)								//CARACTERE DE CONTROLE DETECTADO?
		{
			SERIAL_TX(dado_recebido);											//INDICA CONFIGURACAO AO USUARIO
			settings = EEPROM_Read(999);										//CARREGA A VARIAVEL COM OS VALORES DE CONFIGURACAO EXISTENTE
			dado_recebido = SERIAL_RX();										//LE QUAL A CONFIGURACAO DESEJADA
			SERIAL_TX(dado_recebido);											//RETORNA AO USUARIO
		
			switch(dado_recebido)												//LAÇO VERIFICA QUAL TECLA FOI PRESSIONADA
			{
				case KEYBOARD_I:												//TECLA |I| PRESSIONADA?
					invert_bit(settings,7);										//BIT DE INVERSAO
					break;														//SAI DO LAÇO SWITCH

				case KEYBOARD_S:												//TECLA |S| PRESSIONADA?
					invert_bit(settings,6);										//BIT DE VELOCIDADE						
					break;														//SAI DO LAÇO SWITCH
			
				case KEYBOARD_0:												//TECLA |0| PRESSIONADA?_MODO SLEEP					
					sleep_mode(0x01);	
					break;
			
				case KEYBOARD_1:												//TECLA |1| PRESSIONADA?_RETORNA DO MODO SLEEP		
					sleep_mode(0x00);
					break;
				
				default:														//OUTRO CARACTER PRESSIONADO?
					break;														//SAI DO LAÇO SWITCH
			}
			
			EEPROM_Update(999,settings);										//SALVA AS EDICOES EM EEPROM
			setup();															//CONFIGURA FLAGS
		
		}		

		else if(dado_recebido == KEYBOARD_LF){}									//PREVINE PROBLEMAS COM ALGUNS MONITORES SERIAL

		else																	//CARACTER DE TRATAMENTO NORMAL?
		{
			EEPROM_Update(eeprom_address,dado_recebido);						//ATUALIZA DADO			
			SERIAL_TX(EEPROM_Read(eeprom_address));								//RETORNA COM O VALOR SALVO EM EEPROM, SERVE PARA CONFERENCIA DE CORRUPCAO DE DADOS
			eeprom_address ++;													//INCREMENTA ENDEREÇO
			
			if ((eeprom_address == BUFF_DATA_LIMIT) | (dado_recebido == KEYBOARD_ENTER))	//ATINGIU O LIMITE DESTINADO A CARACTERES
			{																				//OU USUARIO PRESSIONOU |ENTER|
				EEPROM_Update(eeprom_address,KEYBOARD_ENTER);								//INCERE CARACTERE DE FIM
				eeprom_address = 0X00;														//RESETA VARIAVEL DE ENDERECO
				re_buffer(CALL_EEPROM);														//ATUALIZA CONTEUDO DE BUFFER
				SERIAL_Write("OK");
			}
		}	
	}									
}//INTERRUPCAO USART_RX

int main(void)
{		 
	//PORTC DRIVER DE TRANSISTORES
	PORTC = 0b00000000;		//INICIA PORTD
	DDRC  = 0b11111111;		//DEFINE IOs
	
	PORTD = 0b00000000;		//INICIA PORTD
	DDRD  = 0b00111000;		//DEFINE IOs
	
	cli();			//DESABILITA AS INTERRUPCOES _ RECOMENDADO PELO FABRICANTE	
	
		// --- TIMER0 -> RESPONSAVEL POR CHAMADA DE FUNCAO 'DISPLAY' ---
		TCCR0B = 0X04;	//TIMER0 PRESCALER 256
		TIMSK0 = 0X01;	//HABILITADO
		// ------
		
		// --- TIMER1 -> RESPONSAVEL POR ANIMACOES ---
		//TCCR1B = 0X05;	//PRESCALER INICIALIZADO EM setup()	
		TIMSK1 = 0X01;		//HABILITA A INTERRUPCAO POR OVERFLOW DO TIMER1	
		// ------
		
		// --- TIMER2 -> RESPONSAVEL POR STARTUP ---
		TCCR2B = 0X07;		//PRESCALER 1024
		TIMSK2 = 0X01;		//HABILITA A INTERRUPCAO POR OVERFLOW DO TIMER2
		// ------
		
	setup();										//SETA FLAGS DE SETTINGS COM CONTEUDO SALVO EM EEPROM
	SERIAL_Init();									//INICIALIZA COMUNICACAO SERIAL COM INTERRUPCAO PARA RECEPCAO
	re_buffer(STARTUP);								//ADICIONA MENSAGEM DE INICIALIZACAO A BUFFER
		
	sei();											//HABILITA AS INTERRUPCOES
	
    while (1)										//LOOP INFINITO
    {	
		
	}//loop			
	
}//main

void re_buffer(char *data)	//FUNCAO RESPONSAVEL POR ALIMENTAR A VARIAVEL BUFFER 
{
	//VARIAVEIS LOCAIS	
	unsigned char caracter		= KEYBOARD_ENTER;		//CARACTERE A SER TRATADO
	unsigned char chr_size;								//TAMANHO DO CARACTERE
	unsigned int  buffer_index	= 0x00;					//INDICE DA VARIAVEL BUFFER
	unsigned int  data_index	= 0x00;					//INDICE DA EEPROM
		 
	
	 while(1)											//LOOP PREENCHE 'BUFFER' COM CONTEUDO DE PARAMETRO 'DATA'
	{			
					
		if(data == CALL_EEPROM)							//CHAMADA DE EEPROM?
			caracter = EEPROM_Read(data_index);			//CARACTER RECEBE CONTEUDO DE EEPROM
		else											//SE NAO...
			caracter = *(data+data_index);				//CARACTER RECEBE CONTEUDO DO PARAMETRO 'data'
	
		if (caracter == KEYBOARD_ENTER)					//INDICACAO DE FIM?
			break;										//SAI DO LAÇO WHILE
							
		
		// --- BLOCO PARA CONVERSCO ANCII ---
		if((caracter > 47) & (caracter <= 58))		
			caracter = caracter - 48;
		
		else if ((caracter > 64) & (caracter < 91))		
			caracter = caracter - 53;		
			
		else				
			caracter = 38;		
		
		// --- FIM BLOCO CONVERSAO ANSCII ---
		
				
		chr_size = pgm_read_byte(&IMAGES[caracter][0]);		
		for(unsigned char i=0x01; i < chr_size; i++)		//ALIMENTA VARIAVEL BUFFER RESPEIRANDO O TAMANHO DO CARACTERE
		{
			BUFFER[buffer_index] = pgm_read_byte(&IMAGES[caracter][i]);			
			buffer_index++;
		}
				
		BUFFER[buffer_index] = 0x00;				//INSERE ESPAÇO ENTRE CARACTERES			
		buffer_index++;								//INCREMENTA O CONTADOR AUXILIAR			
		data_index++;								//INCREMENTA O CONTADOR AUXILIAR	
		
		if((data_index > BUFF_DATA_LIMIT) ||(buffer_index>BUFFER_SIZE-DISP_COLUMNS_QTY))			//CONDICAO DE ERRO, CASO A LEITURA CHEGUE A LIMITE ESTIPULADO
			/*
				LIMITE 1: LIMITE DA EEPROM
				LIMITE 2: LIMITE DO BUFFER, CONSIDERANDO ESPAÇO PARA O FIM NA ANIMAÇAO HORIZONTAL SCROLL
			*/
			break;
					
	}
		
	for (unsigned char i = buffer_index; i<BUFFER_SIZE; i++)	//PREENCHE O CONTEUDO RESTANTE COM ESPAÇO EM BRANCO
		BUFFER[i] = 0x00;
	
	TIMSK1 = 0X01;												//CERTIFICA-SE DE ATIVAR TIMER1
	buffer_data_size = buffer_index -1;							//RETORNA O NUMERO DE BYTES DE DADOS EM 'buffer' MENOS O ULTIMO ESPAÇO
	
}//re_buffer

void display(char *data, unsigned char anim2, unsigned char linha)		//FUNCAO RESPONSAVEL POR ENVIAR O CONTEUDO DE BUFFER AO DISPLAY, DEVE SER EXECUTADA PERIODICAMENTE PARA MULTIPLEXACAO
{
	//VARIAVEIS LOCAIS		
	unsigned char i = 0x00;							//VARIAVEL AUXILIAR
	
		
	// --- BLOCO PARA DADOS (CARACTERES) ---
	if(DISP_COLUMNS_QTY>anim2)	//PROCESSO INICIAL DE ANIMAÇAO HORIZONTAL SCROLL QUANDO OS CARACTERES CHEGAM DO LADO DIREITO E PREENCHEM COMPLETAMENTE O DISPLAY
	{					// DISPLAY: [____<-XXXX]
	
		for(i=anim2; i != 0xFF; i--)			//LAÇO RESPONSAVEL POR CONTROLAR OS BITS INDIVIDUAIS DOS CARACTERES
			write_595(*(data+i),linha);				
			
		for (i=0x01;i<DISP_COLUMNS_QTY-anim2;i++)		//LAÇO COMPLEMENTA ANIMACAO COM ESPAÇO INICIAL VAZIO 
			write_595(0X00,0);
	}			
	
	else	//EXECUTADO QUANDO CARACTERES SE DESLOCAM PARA ESQUERDA
	{		//DISPLAY: [XXXXXXXX] (TOTALMENTE PREENCHIDO)
		
		for(i=DISP_COLUMNS_QTY; i > 0x00; i--)				//LAÇO RESPONSAVEL POR CONTROLAR OS BITS INDIVIDUAIS DOS CARACTERES
			write_595(*(data+(i+(anim2-DISP_COLUMNS_QTY))),linha);	//LEMBRAR QUE 'anim2' PUSSUI NO MINIMO VALOR IGUAL A 'DISP_COLUMNS_QTY'			
	}
	// --- FIM BLOCO PARA DADOS (CARACTERES) ---
		
	//	COLLUM CONTROL
	// --- BLOCO PARA LINHAS ---
	for (i=0x00;i<0x08;i++)						//ESTE LAÇO PREENCHE O REGISTRADOR RESPONSAVEL PELAS LINHAS
		write_595( ((0b10000000 >> linha) ^ 0xff), i );
	// --- FIM BLOCO PARA LINHAS --- 	
	
	query_595();								//QUERY PARA LINHA ATUAL
				
	
}//display()

void setup()

{
	unsigned char settings = EEPROM_Read(999);
		
	// --- BLOCO CONTROLE DE VELOCIDADE DE HORIZONTAL SCROLL ---
	// CONSIDERA-SE AQUI QUE A INTERRUPCAO GLOBAL ESTEJA DESABILITADA
	if(test_bit(settings,6))
	TCCR1B = 0X03;			//AJUSTA PRESCALER DO TIMER RESPONSAVEL PELA ANIMACAO
	else
	TCCR1B = 0X04;
	// --- BLOCO CONTROLE DE VELOCIDADE DE HORIZONTAL SCROLL ---	
	
}

void sleep_mode(char mode){
	if (mode) {
		TIMSK1 = 0X00;												//DESLIGA TIMER1 (RESPONSAVEL POR ANIMACOES)
		TIMSK0 = 0x00;												//DESLIGA TIMER0 (RESPONSAVEL POR DISPLAY)
		for (char i=0x00;i<0x08;i++) {								//DESLIGA O DISPLAY
			write_595(0xff, i);		
			query_595();
		}
	}
	else {
		h_scroll  = 0;											//RESETA ANIMACAO HORIZONTAL SCROLL		
		TIMSK1 = 0X01;												//ATIVA TIMER1 (RESPONSAVEL POR ANIMACOES)
		TIMSK0 = 0x01;												//ATIVA TIMER0 (RESPONSAVEL POR DISPLAY)
	}
}